import fs from "fs/promises";
import path from "path";
import { glob } from "tinyglobby";
import { optimize } from "svgo";
import { XMLParser, XMLBuilder } from "fast-xml-parser";

import type { ParsedPath } from "path";
import type { Plugin } from "vite";
import type { Config as SvgoConfig } from "svgo";
import type {
  Context,
  ParsedSvg,
  SvgSpritesheetPluginOpts,
  SvgSpritesheetMap,
  SvgSpritesheetInclude,
  SvgSpriteSymbolAttrs,
} from "./types";

const DEFAULT_BATCH_SIZE = 20;

const GENERATED_FILE_HEADER = `
/**
 * WARN: Do not edit this file. It was generated from \`vite.config.ts\`.
 */
`.trim();

/**
 * Generate a TypeScript union type for sprite names
 */
export function generateTypeDeclaration(name: string = "IconName") {
  return (sprites: SvgSpritesheetMap): string => {
    const members = Array.from(sprites.values(), ({ spriteId }) => {
      return `  | "${spriteId}"`;
    }).join("\n");

    return `${GENERATED_FILE_HEADER}\n\nexport type ${name} =\n${members};`;
  };
}

/**
 * Generate a TypeScript enum for sprite names
 */
export function generateEnumDeclaration(name: string = "IconName") {
  return (sprites: SvgSpritesheetMap): string => {
    const members = Array.from(sprites.keys(), (key) => {
      const enumKey = toEnumKey(key);
      const enumValue = toEnumValue(key);
      return `  ${enumKey} = "${enumValue}"`;
    }).join(",\n");

    return `${GENERATED_FILE_HEADER}\n\nexport enum ${name} {\n${members},\n}`;
  };
}

function buildSpritesheetSvg(sprites: SvgSpritesheetMap): string {
  const symbols = Array.from(
    sprites.values(),
    ({ spriteString }) => spriteString,
  ).join("");

  return `<svg xmlns="http://www.w3.org/2000/svg">${symbols}</svg>`;
}

/**
 * Convert a string into a valid UPPER_SNAKE_CASE enum, `_` is used as the
 * default as the key might start with a digit and would be invalid.
 */
function toEnumKey(str: string, prefix: string = "_"): string {
  return prefix + str.toLocaleUpperCase().replace(/[^\w]+/g, "_");
}

/**
 * Convert a string into a kebab-case id
 */
function toEnumValue(str: string, prefix: string = "icon-"): string {
  return `${prefix}${str.replace(/\//g, "-")}`;
}

/**
 * Generate a default `id` attribute value for the `<symbol />` from path parts
 */
function defaultSymbolId(parsedPath: ParsedPath): string {
  const dirParts = parsedPath.dir.split(path.sep).filter(Boolean);

  return ["icon", ...dirParts, parsedPath.name].join("-");
}

/**
 * Optimize using SVGO if a configuration was provided
 */
function optimizeSvg(ctx: Context, input: string, config?: SvgoConfig): string {
  if (!config) {
    return input;
  }

  try {
    const optimized = optimize(input, config);

    if ("data" in optimized && optimized.data.length) {
      return optimized.data;
    } else {
      ctx.plugin.warn(
        `SVGO optimize returned an invalid result for ${ctx.entry}`,
      );
    }
  } catch (err) {
    ctx.plugin.warn(`SVGO could not optimize the file "${ctx.entry}"`);
  }

  return input;
}

/**
 * Resolve base path relative to the the optional base directory if provided
 */
function resolveBasePath(
  ctx: Context,
  include: SvgSpritesheetInclude,
  entry: string,
): ParsedPath {
  let resolved = path.resolve(entry);

  if (include.baseDir) {
    resolved = path.relative(path.resolve(include.baseDir), resolved);
  }

  return path.parse(resolved);
}

/**
 * Parse SVG XML string and warns on missing required attributes. Returns a
 * `ParsedSvg` or `null` if invalid.
 */
function parseSvg(
  ctx: Context,
  input: string,
  xmlParser: XMLParser,
): ParsedSvg | null {
  try {
    const result = xmlParser.parse(input);

    if (!result?.svg) {
      ctx.plugin.warn(`Missing <svg> root in "${ctx.entry}"`);
      return null;
    }

    if (!result.svg["@_viewBox"]) {
      ctx.plugin.warn(`Missing "viewBox" attribute in "${ctx.entry}"`);
      return null;
    }

    return result;
  } catch (err) {
    ctx.plugin.warn(`Failed to parse SVG XML in "${ctx.entry}": ${err}`);
    return null;
  }
}

export function svgSpritesheet(options: SvgSpritesheetPluginOpts): Plugin {
  if (options.include.length === 0) {
    throw new Error("The `include` option must be a non-empty array");
  }

  const xmlOptions = {
    ignoreDeclaration: true,
    ignoreAttributes: false,
    attributeNamePrefix: "@_",
  };

  const batchSize = Math.max(1, options.batchSize ?? DEFAULT_BATCH_SIZE);

  const xmlParser = new XMLParser(xmlOptions);
  const xmlBuilder = new XMLBuilder(xmlOptions);

  const sprites: SvgSpritesheetMap = new Map();

  return {
    name: "vite-plugin-svg-spritesheet",

    async buildStart() {
      for (const include of options.include) {
        let entries: string[] = [];
        try {
          entries = await glob(include.pattern);
        } catch (err) {
          this.error(
            `Failed to glob files for pattern "${include.pattern}": ${err}`,
          );
        }

        // Parallel processing of files in batches to avoid file exhaustion
        for (let i = 0; i < entries.length; i += batchSize) {
          const batch = entries.slice(i, i + batchSize);

          await Promise.all(
            batch.map(async (entry) => {
              try {
                const ctx = { entry, plugin: this };
                const file = await fs.readFile(entry, "utf8");

                const parsedPath = resolveBasePath(ctx, include, entry);
                const svg = optimizeSvg(ctx, file, options.svgoConfig);
                const svgObj = parseSvg(ctx, svg, xmlParser);
                if (!svgObj) {
                  return;
                }

                const spriteId = options.customSymbolId
                  ? options.customSymbolId(parsedPath)
                  : defaultSymbolId(parsedPath);

                const symbolAttrs: SvgSpriteSymbolAttrs = {
                  ...svgObj.svg,
                  "@_id": spriteId,
                  "@_viewBox": svgObj.svg["@_viewBox"],
                };

                // Remove unnecessary attributes for the `<symbol />`
                for (const attr of ["@_xmlns", "@_width", "@_height"]) {
                  delete symbolAttrs[attr];
                }

                sprites.set(spriteId, {
                  spriteId,
                  spriteString: xmlBuilder.build({ symbol: symbolAttrs }),
                });
              } catch (err) {
                this.warn(`Failed to process SVG file "${entry}": ${err}`);
              }
            }),
          );
        }
      }

      if (sprites.size === 0) {
        this.warn("No sprites were generated");
      } else {
        this.info(`Generated ${sprites.size} SVG sprites üë®üèΩ‚Äçüé®`);
      }

      const spritesheetSvg = buildSpritesheetSvg(sprites);

      try {
        await fs.writeFile(options.output, spritesheetSvg, "utf8");
      } catch {
        this.error(`Failed to write spritesheet to "${options.output}"`);
      }

      // If defined, generate TypeScript types
      if (options.types) {
        const declaration = options.types.generateDeclaration
          ? options.types.generateDeclaration(sprites)
          : generateEnumDeclaration()(sprites);

        try {
          await fs.writeFile(options.types.output, declaration, "utf8");
        } catch {
          this.warn(`Failed to write types to "${options.types.output}"`);
        }
      }
    },
  };
}
